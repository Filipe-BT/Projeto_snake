import pygame
import sys
import random
import os

# ---------- Configurações ----------
SCREEN_WIDTH = 640
SCREEN_HEIGHT = 480
CELL_SIZE = 20  # tamanho do "pixel" da grade
FPS = 10

# cores (R, G, B)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
GREEN = (0, 180, 0)
DARK_GREEN = (0, 120, 0)
RED = (200, 0, 0)
GRAY = (200, 200, 200)

HIGH_SCORE_FILE = "highscore.txt"

# ---------- Funções utilitárias ----------
def load_highscore():
    if not os.path.exists(HIGH_SCORE_FILE):
        return 0
    try:
        with open(HIGH_SCORE_FILE, "r") as f:
            return int(f.read().strip() or 0)
    except Exception:
        return 0

def save_highscore(score):
    hs = load_highscore()
    if score > hs:
        with open(HIGH_SCORE_FILE, "w") as f:
            f.write(str(score))

def draw_text(surf, text, size, x, y, center=False):
    font = pygame.font.SysFont("consolas", size)
    text_surf = font.render(text, True, WHITE)
    text_rect = text_surf.get_rect()
    if center:
        text_rect.center = (x, y)
    else:
        text_rect.topleft = (x, y)
    surf.blit(text_surf, text_rect)

# ---------- Classe do Jogo ----------
class SnakeGame:
    def __init__(self):
        pygame.init()
        pygame.display.set_caption("Snake - Python + Pygame")
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        self.clock = pygame.time.Clock()
        self.reset()

    def reset(self):
        # grade
        self.cols = SCREEN_WIDTH // CELL_SIZE
        self.rows = SCREEN_HEIGHT // CELL_SIZE

        # cobra: lista de (x, y), cada coordenada em células da grade
        start_x = self.cols // 2
        start_y = self.rows // 2
        self.snake = [(start_x, start_y), (start_x - 1, start_y), (start_x - 2, start_y)]
        self.direction = (1, 0)  # deslocamento (dx, dy) em células
        self.next_direction = self.direction
        self.spawn_food()
        self.score = 0
        self.game_over = False
        self.paused = False
        self.speed = FPS
        self.highscore = load_highscore()

    def spawn_food(self):
        while True:
            x = random.randint(0, self.cols - 1)
            y = random.randint(0, self.rows - 1)
            if (x, y) not in self.snake:
                self.food = (x, y)
                break

    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                save_highscore(self.score)
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key in (pygame.K_UP, pygame.K_w):
                    if self.direction != (0, 1):  # não permitir reversão instantânea
                        self.next_direction = (0, -1)
                elif event.key in (pygame.K_DOWN, pygame.K_s):
                    if self.direction != (0, -1):
                        self.next_direction = (0, 1)
                elif event.key in (pygame.K_LEFT, pygame.K_a):
                    if self.direction != (1, 0):
                        self.next_direction = (-1, 0)
                elif event.key in (pygame.K_RIGHT, pygame.K_d):
                    if self.direction != (-1, 0):
                        self.next_direction = (1, 0)
                elif event.key == pygame.K_p:
                    self.paused = not self.paused
                elif event.key == pygame.K_r and self.game_over:
                    # reiniciar jogo
                    self.reset()
                elif event.key == pygame.K_ESCAPE:
                    save_highscore(self.score)
                    pygame.quit()
                    sys.exit()

    def update(self):
        if self.game_over or self.paused:
            return

        # aplica próxima direção (proteção contra reversão)
        self.direction = self.next_direction

        head_x, head_y = self.snake[0]
        dx, dy = self.direction
        new_head = (head_x + dx, head_y + dy)

        # checar colisão com parede
        if (new_head[0] < 0 or new_head[0] >= self.cols or
            new_head[1] < 0 or new_head[1] >= self.rows):
            self.game_over = True
            save_highscore(self.score)
            return

        # checar colisão com o próprio corpo
        if new_head in self.snake:
            self.game_over = True
            save_highscore(self.score)
            return

        # mover cobra
        self.snake.insert(0, new_head)

        # checar comida
        if new_head == self.food:
            self.score += 10
            # opcional: aumentar velocidade gradualmente
            if self.score % 50 == 0:
                self.speed = min(self.speed + 1, 25)
            self.spawn_food()
        else:
            # remover cauda
            self.snake.pop()

    def draw_grid(self):
        for x in range(0, SCREEN_WIDTH, CELL_SIZE):
            pygame.draw.line(self.screen, GRAY, (x, 0), (x, SCREEN_HEIGHT))
        for y in range(0, SCREEN_HEIGHT, CELL_SIZE):
            pygame.draw.line(self.screen, GRAY, (0, y), (SCREEN_WIDTH, y))

    def draw(self):
        self.screen.fill(BLACK)

        # desenha grid opcional (comentar se não quiser)
        # self.draw_grid()

        # desenha comida
        fx, fy = self.food
        food_rect = pygame.Rect(fx * CELL_SIZE, fy * CELL_SIZE, CELL_SIZE, CELL_SIZE)
        pygame.draw.rect(self.screen, RED, food_rect)

        # desenha cobra (cabeça com cor diferente)
        for i, (x, y) in enumerate(self.snake):
            rect = pygame.Rect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE)
            if i == 0:
                pygame.draw.rect(self.screen, GREEN, rect)
                # borda na cabeça
                pygame.draw.rect(self.screen, DARK_GREEN, rect, 2)
            else:
                pygame.draw.rect(self.screen, (30, 200, 30), rect)

        # HUD: score e instruções
        draw_text(self.screen, f"Score: {self.score}", 20, 8, 8)
        draw_text(self.screen, f"Highscore: {self.highscore}", 20, SCREEN_WIDTH - 8, 8, center=False)
        draw_text(self.screen, "P: Pausar  R: Reiniciar  ESC: Sair", 16, 8, SCREEN_HEIGHT - 28)

        if self.paused:
            draw_text(self.screen, "PAUSADO", 48, SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2, center=True)

        if self.game_over:
            draw_text(self.screen, "GAME OVER", 64, SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 24, center=True)
            draw_text(self.screen, "Pressione R para reiniciar", 24, SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 36, center=True)

        pygame.display.flip()

    def run(self):
        while True:
            self.handle_events()
            if not self.paused:
                self.update()
            self.draw()
            # controla FPS dependendo da velocidade
            self.clock.tick(self.speed)

# ---------- Execução ----------
if __name__ == "__main__":
    game = SnakeGame()
    game.run()
